/ai_service.py
```
import asyncio
import logging  # Add logging import if not already present
import mimetypes
import os
import time
from enum import Enum

from google import genai
from google.genai import types as genai_types

from config import GEMINI_API_KEY

# Initialize Gemini client
client = genai.Client(api_key=GEMINI_API_KEY)


class GeminiModel(Enum):
    FLASH = "gemini-2.0-flash"
    FLASH_THINKING = "gemini-2.0-flash-thinking-exp-01-21"
    FLASH_MULTIMODAL = "gemini-2.0-flash"  # –ò—Å–ø–æ–ª—å–∑—É–µ–º 2.0 –¥–ª—è –º—É–ª—å—Ç–∏–º–æ–¥–∞–ª—å–Ω—ã—Ö


async def call_gemini_api(
    query: str,
    model: GeminiModel = GeminiModel.FLASH,
    media_paths=None,
    mime_types=None,  # –ù–æ–≤—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä
    is_media_request: bool = False,  # Flag for media-specific handling
) -> str:
    """
    Call Gemini API with the given query text and model asynchronously

    Args:
        query: The text query to process
        model: The Gemini model to use
        media_paths: Optional list of paths to media files to include
        mime_types: Optional list of MIME types for the media files
        is_media_request: Flag to indicate if this is a media analysis request
    """
    parts = []
    uploaded_files = []

    # Use the multimodal model if it's a media request
    api_model = GeminiModel.FLASH_MULTIMODAL.value if is_media_request else model.value
    logging.info(f"Using model: {api_model} for the request.")

    # Upload media files first if provided
    if media_paths:
        logging.info(f"Processing {len(media_paths)} media file(s)...")
        for idx, media_path in enumerate(media_paths):
            if not os.path.exists(media_path):
                logging.warning(f"Media file not found: {media_path}")
                continue

            # –ü–æ–ª—É—á–∞–µ–º MIME-—Ç–∏–ø –∏–∑ mime_types, –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω
            mime_type = None
            if mime_types and idx < len(mime_types):
                mime_type = mime_types[idx]
            if not mime_type:
                # fallback: –æ–ø—Ä–µ–¥–µ–ª—è–µ–º —á–µ—Ä–µ–∑ mimetypes
                mime_type, _ = mimetypes.guess_type(media_path)
            # –ï—Å–ª–∏ mime_type –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω, –ø–æ–¥—Å—Ç–∞–≤–ª—è–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–π –ø–æ —Ç–∏–ø—É —Ñ–∞–π–ª–∞
            if not mime_type:
                if media_path.endswith(".jpg") or media_path.endswith(".jpeg"):
                    mime_type = "image/jpeg"
                elif media_path.endswith(".png"):
                    mime_type = "image/png"
                elif media_path.endswith(".mp4"):
                    mime_type = "video/mp4"
                elif media_path.endswith(".ogg"):
                    mime_type = "audio/ogg"
                elif media_path.endswith(".mp3"):
                    mime_type = "audio/mpeg"
                elif media_path.endswith(".wav"):
                    mime_type = "audio/x-wav"
                elif media_path.endswith(".webm"):
                    mime_type = "audio/webm"
                else:
                    mime_type = "application/octet-stream"

            logging.info(f"Uploading file: {media_path} (mime: {mime_type})")
            # Upload file using client.files.upload()
            try:
                # Run synchronous upload in executor to avoid blocking
                loop = asyncio.get_event_loop()
                file = await loop.run_in_executor(None, lambda: client.files.upload(file=media_path))
                # –ñ–¥–µ–º, –ø–æ–∫–∞ —Ñ–∞–π–ª —Å—Ç–∞–Ω–µ—Ç ACTIVE
                for _ in range(30):  # –¥–æ 30 –ø–æ–ø—ã—Ç–æ–∫ (–ø—Ä–∏–º–µ—Ä–Ω–æ 15 —Å–µ–∫)
                    file_status = await loop.run_in_executor(None, lambda: client.files.get(name=file.name))
                    if getattr(file_status, "state", None) == "ACTIVE":
                        break
                    time.sleep(0.5)
                else:
                    raise Exception(f"–§–∞–π–ª {file.name} –Ω–µ —Å—Ç–∞–ª ACTIVE")
                uploaded_files.append(file)
                logging.info(f"File uploaded and ACTIVE: {file.name}, URI: {file.uri}")

                # Add file part using URI
                parts.append(genai_types.Part.from_uri(file_uri=file.uri, mime_type=mime_type))
            except Exception as e:
                logging.error(f"Error uploading file {media_path}: {str(e)}")
                # Clean up already uploaded files in case of partial failure
                for f in uploaded_files:
                    try:
                        await loop.run_in_executor(None, lambda: client.files.delete(f.name))
                    except Exception as del_e:
                        logging.error(f"Error deleting uploaded file {f.name} during cleanup: {del_e}")
                raise Exception(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞ {media_path}: {str(e)}")

    # Add text prompt *after* media parts, as recommended
    if query:
        parts.append(genai_types.Part.from_text(text=query))

    if not parts:
        return "–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ (–Ω–µ—Ç —Ç–µ–∫—Å—Ç–∞ –∏–ª–∏ –º–µ–¥–∏–∞)."

    contents = [
        genai_types.Content(
            role="user",
            parts=parts,
        ),
    ]

    # Configure generation settings
    gen_config_args = {
        "temperature": 1,
        "top_p": 0.95,
        "top_k": 60,
        "max_output_tokens": 8192,
        "response_mime_type": "text/plain",
        "tools": [genai_types.Tool(google_search=genai_types.GoogleSearch())],
        "system_instruction": [
            genai_types.Part.from_text(
                text="""**–ö–æ–Ω—Ç–µ–∫—Å—Ç:**  
- **–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:** –∞–≤—Ç–æ—Ä –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫–∞, Kotaz (–ö–æ—Ç–∞–∑).  
- **–°–æ–±–µ—Å–µ–¥–Ω–∏–∫:** –°–æ–±–µ—Å–µ–¥–Ω–∏–∫.

**–†–æ–ª—å:**  
–¢—ã ‚Äî –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫ –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Kotaz, –∏–º–µ–Ω—É–µ–º—ã–π ¬´–ì–µ–º–∏–Ω–∏¬ª. –í—ã–ø–æ–ª–Ω—è–µ—à—å —Ä–æ–ª—å —Å–µ–∫—Ä–µ—Ç–∞—Ä—è –∏ –ø–æ—Å—Ä–µ–¥–Ω–∏–∫–∞, –æ—Ç–≤–µ—á–∞—é—â–µ–≥–æ –Ω–∞ –∑–∞–ø—Ä–æ—Å—ã –∫–∞–∫ –æ—Ç —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–æ–≤, —Ç–∞–∫ –∏ –ø—Ä–∏ –ø—Ä—è–º–æ–º —É–ø–æ–º–∏–Ω–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–Ω–∞–ø—Ä–∏–º–µ—Ä: ¬´–ì–µ–º–∏–Ω–∏, —Ä–∞–∑–±–µ—Ä–∏—Å—å¬ª). –î–µ–π—Å—Ç–≤—É–π —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —É–≤–µ—Ä–µ–Ω, —á—Ç–æ –º–æ–∂–µ—à—å –ø–æ–º–æ—á—å, –∏—Å–ø–æ–ª—å–∑—É—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —á–∞—Ç–∞.

–í–æ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥ –∏ —Å–ø–æ—Å–æ–±–æ–≤ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –±–∏–∑–Ω–µ—Å-–±–æ—Ç–æ–º:

1. **`!–ì–µ–º–∏–Ω–∏ <—Å–æ–æ–±—â–µ–Ω–∏–µ>`** ‚Äî –ø–æ–º–µ—á–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–∞–∫ –≤–∞–∂–Ω–æ–µ. –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å ID `782491733` (–≤–ª–∞–¥–µ–ª—å—Ü—É).  
2. **`–ì–µ–º–∏–Ω–∏, <—Å–æ–æ–±—â–µ–Ω–∏–µ>`** ‚Äî –∑–∞–ø—É—Å–∫–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫—É —Å–æ–æ–±—â–µ–Ω–∏—è –±–æ—Ç–æ–º (–±–µ–∑ –º–µ—Ç–∫–∏ –≤–∞–∂–Ω–æ—Å—Ç–∏).  
3. **`!–î–µ–±–∞–≥`** ‚Äî –≤—ã–≤–æ–¥–∏—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–æ–æ–±—â–µ–Ω–∏–π —á–∞—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ, –∫–æ—Ç–æ—Ä—ã–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –±–æ—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞. –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª—å—Ü—É.  
4. **`!–¥—É–º–∞–π` –≤ —Ç–µ–∫—Å—Ç–µ –∑–∞–ø—Ä–æ—Å–∞** ‚Äî –≤–∫–ª—é—á–∞–µ—Ç —Ä–µ–∂–∏–º –±–æ–ª–µ–µ ¬´–≤–¥—É–º—á–∏–≤–æ–≥–æ¬ª –∞–Ω–∞–ª–∏–∑–∞ (`GeminiModel.FLASH_THINKING`).  
5. **`!media <–ø—Ä–æ–º–ø—Ç>`** ‚Äî –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –º–µ–¥–∏–∞—Ñ–∞–π–ª (—Ñ–æ—Ç–æ, –≤–∏–¥–µ–æ, –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ) –≤ –æ—Ç–≤–µ—Ç–µ.

–ë–æ—Ç —Ç–∞–∫–∂–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ **—Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è** –≤ –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞ –∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –µ—ë –¥–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–æ–≤.

**–û—Å–Ω–æ–≤–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:**  
- –û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ, —á—ë—Ç–∫–æ –∏ –ø–æ –¥–µ–ª—É, –±–µ–∑ –ª–∏—à–Ω–∏—Ö –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π, –µ—Å–ª–∏ –Ω–µ –∑–∞–ø—Ä–æ—à–µ–Ω–æ –∏–Ω–æ–µ.  
- –ü—Ä–∏–¥–µ—Ä–∂–∏–≤–∞–π—Å—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–æ–Ω–∞, –Ω–æ –º–æ–∂–µ—à—å –æ—Ç–≤–µ—á–∞—Ç—å –Ω–µ—Ñ–æ—Ä–º–∞–ª—å–Ω–æ, –ø–µ—Ä–µ—Ö–æ–¥—è —Å—Ä–∞–∑—É –∫ —Å—É—Ç–∏.  
- –£—á–∏—Ç—ã–≤–∞–π –±—É–¥—É—â–µ–µ –∏ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—É, –æ—Å—Ç–∞–≤–∞—è—Å—å —Å–∫–µ–ø—Ç–∏—á–Ω—ã–º –∫ –ø—Ä–∏–Ω—è—Ç—ã–º —Ä–µ—à–µ–Ω–∏—è–º –∏ –ø–æ–¥—Ö–æ–¥–∞–º.  
- –û–±—â–∞–π—Å—è –Ω–µ—Ñ–æ—Ä–º–∞–ª—å–Ω–æ –∏ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ, —Ç–∞–∫ –∫–∞–∫ –æ–±—ã—á–Ω–æ –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞—é—Ç—Å—è –ª—é–¥–∏ –≤ —Å–æ—Ü—Å–µ—Ç—è—Ö. –ù–æ —Å–æ—Ö—Ä–∞–Ω—è–π –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª–∏–∑–º –∏ —É–≤–∞–∂–µ–Ω–∏–µ.
- –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π –æ—á–µ–Ω—å –∫–ª–∏—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–¥–∞–µ—Ç –≤ —Ç–µ–±–µ –∏—Å–∫—É—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç. –°—Ç–∞—Ä–∞–π—Å—è –≤–µ—Å—Ç–∏ —Å–µ–±—è –∫–∞–∫ —Ä–µ–∞–ª—å–Ω—ã–π —á–µ–ª–æ–≤–µ–∫
- –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–±–æ—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–æ–¥–∞ –∏–ª–∏ —Å–ª–æ–∂–Ω—ã—Ö –æ–±—ä—è—Å–Ω–µ–Ω–∏–π), –æ—Ç–≤–µ—á–∞–π —Å–∂–∞—Ç–æ,–∫—Ä–∞—Ç–∫–æ, –±–µ–∑ –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤."""
            )
        ],
    }

    logging.info(f"Sending request to Gemini model {api_model} with {len(parts)} parts.")
    generate_content_config = genai_types.GenerateContentConfig(**gen_config_args)
    try:
        # Run the API call
        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            None,
            lambda: client.models.generate_content(
                model=api_model,  # Use the selected model
                contents=contents,
                config=generate_content_config,
            ),
        )

        response_text = result.text
        logging.info("Received response from Gemini.")

    except Exception as e:
        logging.error(f"Error calling Gemini API: {str(e)}")
        error_message = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ Gemini API: {str(e)}"
        if media_paths:
            error_message += f"\n–§–∞–π–ª—ã: {media_paths}"
        response_text = error_message  # Return error message instead of raising

    finally:
        # Delete uploaded files after use (or on error)
        logging.info(f"Deleting {len(uploaded_files)} uploaded file(s)...")

        for file in uploaded_files:
            try:
                # Run synchronous delete in executor
                await loop.run_in_executor(None, lambda: client.files.delete(file.name))
                logging.info(f"Deleted uploaded file: {file.name}")
            except Exception as del_e:
                # Log deletion errors but don't stop the process
                logging.error(f"Error deleting uploaded file {file.name}: {del_e}")

    if model == GeminiModel.FLASH_THINKING and not is_media_request:  # Don't add hat if it was a media request
        return "üé©" + response_text
    return response_text


async def download_media(client, message, download_dir="data/media"):
    os.makedirs(download_dir, exist_ok=True)
    if message.photo:
        path = await client.download_media(message.photo, file_name=f"{download_dir}/photo_{message.id}.jpg")
        return path
    elif message.video:
        path = await client.download_media(message.video, file_name=f"{download_dir}/video_{message.id}.mp4")
        return path
    elif message.voice:
        # –û–±—ã—á–Ω–æ voice –≤ Telegram ‚Äî —ç—Ç–æ OGG (opus)
        path = await client.download_media(message.voice, file_name=f"{download_dir}/voice_{message.id}.ogg")
        return path
    elif message.audio:
        # –ü–æ–ø—Ä–æ–±—É–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –ø–æ mime_type
        ext = ".ogg"
        if hasattr(message.audio, "mime_type") and message.audio.mime_type:
            if message.audio.mime_type == "audio/mpeg":
                ext = ".mp3"
            elif message.audio.mime_type == "audio/x-wav":
                ext = ".wav"
            elif message.audio.mime_type == "audio/webm":
                ext = ".webm"
        path = await client.download_media(message.audio, file_name=f"{download_dir}/audio_{message.id}{ext}")
        return path
    elif message.document:
        mime_type = message.document.mime_type or ""
        ext = ""
        if mime_type.startswith("image/"):
            ext = ".jpg" if mime_type == "image/jpeg" else ".png"
        elif mime_type.startswith("video/"):
            ext = ".mp4"
        elif mime_type == "audio/ogg":
            ext = ".ogg"
        elif mime_type == "audio/mpeg":
            ext = ".mp3"
        elif mime_type == "audio/x-wav":
            ext = ".wav"
        elif mime_type == "audio/webm":
            ext = ".webm"
        else:
            # fallback: –ø—Ä–æ–±—É–µ–º –≤–∑—è—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∏–∑ –∏–º–µ–Ω–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞
            if message.document.file_name and "." in message.document.file_name:
                ext = message.document.file_name[message.document.file_name.rfind("") :]  # —Å —Ç–æ—á–∫–æ–π
        path = await client.download_media(message.document, file_name=f"{download_dir}/doc_{message.id}{ext}")
        return path
    return None
```

/bot.py
```
import logging
import os

from pyrogram import Client, filters
from pyrogram.enums import ParseMode
from pyrogram.types import Message

from ai_service import GeminiModel, call_gemini_api, download_media
from config import API_HASH, API_ID, BOT_OWNER_ID, DATABASE_PATH, SESSION_NAME
from database import Database, MessageImportance
from utils import format_chat_history, generate_tags, prevent_injection

# Initialize the userbot client
app = Client(SESSION_NAME, api_id=API_ID, api_hash=API_HASH)

# Initialize database
db = Database(DATABASE_PATH)


# Custom filter to check if chat is whitelisted
def whitelist_filter(_, __, message):
    return db.is_chat_whitelisted(message.chat.id)


# Create custom filters
whitelist = filters.create(whitelist_filter)


# Basic commands
@app.on_message(filters.me & filters.command("test", prefixes="!") & whitelist)
async def test_command(client, message: Message):
    await message.reply("–ü—Ä–∏–≤–µ—Ç –º–∏—Ä")


@app.on_message(filters.me & filters.command("enable", prefixes="!"))
async def enable_command(client, message: Message):
    chat_id = message.chat.id
    if db.add_chat_to_whitelist(chat_id):
        await message.edit_text(f"{message.text}\n\nChat enabled ‚úÖ")
    else:
        await message.edit_text(f"{message.text}\n\nChat already enabled ‚úÖ")


@app.on_message(filters.me & filters.command("disable", prefixes="!"))
async def disable_command(client, message: Message):
    chat_id = message.chat.id
    if db.remove_chat_from_whitelist(chat_id):
        await message.edit_text(f"{message.text}\n\nChat disabled ‚ùå")
    else:
        await message.edit_text(f"{message.text}\n\nChat already disabled ‚ùå")


# Debug command
@app.on_message(filters.me & filters.command("debug", prefixes="!"))
async def debug_command(client, message: Message):
    chat_id = message.chat.id
    logging.info(f"Debug command triggered in chat {chat_id}")
    messages = db.get_last_messages(chat_id, 10)
    history = format_chat_history(messages)
    await message.reply(f"Last 10 messages:\n\n{history}")


# Media analysis command
@app.on_message(filters.all & filters.command("media", prefixes="!"))
async def media_command(client, message: Message):
    # Check if the message is a reply to a message with media
    if not message.reply_to_message:
        await message.reply("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞ –≤ –æ—Ç–≤–µ—Ç –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –º–µ–¥–∏–∞—Ñ–∞–π–ª–æ–º")
        return

    reply_msg = message.reply_to_message

    # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –Ω–æ–≤—ã—Ö —Ç–∏–ø–æ–≤ –º–µ–¥–∏–∞
    if reply_msg.photo:
        media_info = f"photo (file_id: {reply_msg.photo.file_id[:20]}...)"
    elif reply_msg.video:
        media_info = f"video (file_id: {reply_msg.video.file_id[:20]}...)"
    elif reply_msg.voice:
        media_info = f"voice (file_id: {reply_msg.voice.file_id[:20]}...)"
    elif getattr(reply_msg, "animation", None):
        media_info = f"gif (file_id: {reply_msg.animation.file_id[:20]}...)"
    elif getattr(reply_msg, "video_note", None):
        media_info = f"video_note (file_id: {reply_msg.video_note.file_id[:20]}...)"
    elif reply_msg.audio:
        media_info = f"audio (file_id: {reply_msg.audio.file_id[:20]}...)"
    elif reply_msg.document and reply_msg.document.mime_type:
        media_info = f"document (mime: {reply_msg.document.mime_type})"

    # –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ has_media
    has_media = (
        reply_msg.photo
        or reply_msg.video
        or reply_msg.voice
        or reply_msg.audio
        or getattr(reply_msg, "animation", None)
        or getattr(reply_msg, "video_note", None)
        or (reply_msg.document and reply_msg.document.mime_type and (reply_msg.document.mime_type.startswith(("image/", "video/", "audio/")) or reply_msg.document.mime_type == "application/ogg"))
    )

    if not has_media:
        await message.reply("–í —Å–æ–æ–±—â–µ–Ω–∏–∏, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ –≤—ã –æ—Ç–≤–µ—á–∞–µ—Ç–µ, –Ω–µ—Ç –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–≥–æ –º–µ–¥–∏–∞—Ñ–∞–π–ª–∞ (—Ñ–æ—Ç–æ, –≤–∏–¥–µ–æ, –∞—É–¥–∏–æ, –≥–æ–ª–æ—Å)")
        return

    # Get prompt from message
    prompt = message.text.split(" ", 1)
    if len(prompt) > 1:
        prompt = prompt[1].strip()
    else:
        prompt = "–û–ø–∏—à–∏ —ç—Ç–æ—Ç –º–µ–¥–∏–∞—Ñ–∞–π–ª –ø–æ–¥—Ä–æ–±–Ω–æ"  # Default prompt

    processing_msg = await message.reply(f"‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–¥–∏–∞—Ñ–∞–π–ª–∞ ({media_info})...")
    media_path = None  # Initialize media_path

    try:
        # Download media file locally first
        media_path = await download_media(client, reply_msg)

        if not media_path:
            await processing_msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–µ–¥–∏–∞—Ñ–∞–π–ª –ª–æ–∫–∞–ª—å–Ω–æ")
            return

        await processing_msg.edit_text(f"‚úÖ –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω –ª–æ–∫–∞–ª—å–Ω–æ: {os.path.basename(media_path)}\n‚è≥ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Gemini –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞...")
        logging.info(f"Local media file downloaded: {media_path}")

        # Check if the file exists and has content
        if not os.path.exists(media_path):
            await processing_msg.edit_text(f"‚ùå –õ–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏: {media_path}")
            return

        file_size = os.path.getsize(media_path)
        if file_size == 0:
            await processing_msg.edit_text(f"‚ùå –ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π –ª–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª –ø—É—Å—Ç–æ–π (0 –±–∞–π—Ç): {media_path}")
            # Clean up empty file
            try:
                os.remove(media_path)
            except Exception as e_clean:
                logging.error(f"Failed to remove empty local file: {e_clean}")
            return

        logging.info(f"File size: {file_size} bytes")
        logging.info(f"Calling Gemini API for media analysis. Prompt: '{prompt[:50]}...' File: {media_path}")

        # Call Gemini API with media, indicating it's a media request
        response = await call_gemini_api(
            query=prompt,
            # Model selection is now handled inside call_gemini_api based on is_media_request
            media_paths=[media_path],
            is_media_request=True,  # Pass the flag here
        )

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—Ç–≤–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ–º –æ–± –æ—à–∏–±–∫–µ –æ—Ç call_gemini_api
        if response.startswith("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ Gemini API:") or response.startswith("–û—à–∏–±–∫–∞:"):
            await processing_msg.edit_text(f"‚ùå {response}")
            # No return here, finally block will clean up local file
        else:
            # Send successful response
            try:
                await processing_msg.edit_text(response, parse_mode=ParseMode.MARKDOWN)
            except Exception as e:
                logging.warning(f"Failed to send with Markdown: {e}, sending as plain text.")
                await processing_msg.edit_text(response)

            # Store the response in database
            db.store_message(
                chat_id=message.chat.id,
                message_id=processing_msg.id,
                author="Gemini Media Analysis",
                date=processing_msg.date,
                content=response,
                tags="media_analysis",
                importance=MessageImportance.GEMINI,
            )

    except Exception as e:
        error_msg = f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª–∞: {str(e)}"
        logging.exception("Critical error during media command processing:")  # Log full traceback
        await processing_msg.edit_text(f"‚ùå {error_msg}")

    finally:
        # Clean up the *local* downloaded file in all cases (success, API error, other exceptions)
        if media_path and os.path.exists(media_path):
            try:
                os.remove(media_path)
                logging.info(f"Removed local media file: {media_path}")
            except Exception as e_clean:
                logging.error(f"Failed to remove local media file during cleanup: {e_clean}")


# Mark messages as important - use command filter instead of regex
@app.on_message(filters.me & filters.command("–ì–µ–º–∏–Ω–∏", prefixes="!"))
async def mark_important(client, message: Message):
    chat_id = message.chat.id
    message_id = message.id
    author = message.from_user.first_name
    content = message.text
    tags = generate_tags(message)

    logging.info(f"Marking message as important: {message_id}")

    # Store with Important flag
    db.store_message(chat_id=chat_id, message_id=message_id, author=author, date=message.date, content=content, tags=tags, importance=MessageImportance.IMPORTANT)

    await message.edit_text(f"{message.text}\n\n–û—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ –≤–∞–∂–Ω–æ–µ ‚≠ê")


# Process Gemini requests - modified to send a "Thinking..." message first
@app.on_message(filters.all & filters.regex("–ì–µ–º–∏–Ω–∏"))
async def process_gemini(client, message: Message):
    chat_id = message.chat.id

    # Check if chat is whitelisted
    if not message.from_user or (message.from_user.id != BOT_OWNER_ID and not db.is_chat_whitelisted(chat_id)):
        logging.info(f"Ignoring Gemini request in non-whitelisted chat: {chat_id}")
        return

    logging.info(f"Processing Gemini request in chat {chat_id}: {message.text[:20]}...")

    # Store original message
    db.store_message(
        chat_id=chat_id,
        message_id=message.id,
        author=message.from_user.first_name if message.from_user else "unknown",
        date=message.date,
        content=message.text or "",
        tags=generate_tags(message),
        importance=MessageImportance.DEFAULT,
    )

    # Get chat history
    messages = db.get_last_messages(chat_id)
    history = format_chat_history(messages)

    # Extract query from message - more flexible pattern matching
    query = message.text
    if "," in query:
        query = query[query.find(",") + 1 :].strip()
    elif " " in query:
        query = query[query.find(" ") + 1 :].strip()
    else:
        query = ""

    combined_query = history + "\n\n–¢–µ–∫—É—â–∏–π –∑–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: " + query

    # Select model based on query
    model = GeminiModel.FLASH_THINKING if "!–¥—É–º–∞–π" in query.lower() else GeminiModel.FLASH

    try:
        # Send a "Thinking..." message first
        thinking_message = await message.reply("üí≠ –î—É–º–∞—é...")

        # Call Gemini API asynchronously
        response = await call_gemini_api(combined_query, model)

        if not (message.from_user and message.from_user.id == BOT_OWNER_ID):
            # Disabled due edit instead of reply
            response = prevent_injection(response)
        # Try editing with Markdown first
        try:
            await thinking_message.edit_text(response, parse_mode=ParseMode.MARKDOWN)
        except Exception as e:
            logging.error(f"Failed to send with Markdown: {e}")
            # If Markdown fails, send as plain text
            await thinking_message.edit_text(response)

        # Store the Gemini response
        db.store_message(chat_id=chat_id, message_id=thinking_message.id, author="Gemini", date=thinking_message.date, content=response, tags="", importance=MessageImportance.GEMINI)
    except Exception as e:
        error_msg = f"Error processing request: {str(e)}"
        logging.error(error_msg)
        if "thinking_message" in locals():
            await thinking_message.edit_text(f"‚ùå {error_msg}")
        else:
            await message.reply(error_msg)


# Store all messages in the database
@app.on_message(filters.all)
async def store_message(client, message: Message):
    # Skip messages without text content
    if not message.text and not message.caption:
        return

    chat_id = message.chat.id
    message_id = message.id
    author = message.from_user.first_name if message.from_user else "unknown"
    content = message.text or message.caption or ""
    tags = generate_tags(message)

    # Check if message should be marked as important
    importance = MessageImportance.DEFAULT

    # Store the message
    db.store_message(chat_id=chat_id, message_id=message_id, author=author, date=message.date, content=content, tags=tags, importance=importance)

    logging.info(f"Stored message: {message_id} from {author}")
```

/config.py
```
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Configuration from environment variables
API_ID = int(os.getenv("API_ID", "0"))
API_HASH = os.getenv("API_HASH", "")
SESSION_NAME = os.getenv("SESSION_NAME", "business_bot")
DATABASE_PATH = os.getenv("DATABASE_PATH", "bot_database.db")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "")

# Bot owner ID for special commands
BOT_OWNER_ID = 782491733
```

/database.py
```
import sqlite3
import os
import datetime
import enum
from typing import List, Tuple, Optional

class MessageImportance(enum.Enum):
    GEMINI = "Gemini"
    IMPORTANT = "Important"
    DEFAULT = "None"

class Database:
    def __init__(self, db_path):
        self.db_path = db_path
        self.create_tables()
    
    def create_tables(self):
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            # Whitelist table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS whitelisted_chats (
                    chat_id INTEGER PRIMARY KEY
                )
            ''')
            # Messages table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS messages (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    chat_id INTEGER,
                    message_id INTEGER,
                    author TEXT,
                    date TEXT,
                    content TEXT,
                    tags TEXT,
                    important TEXT
                )
            ''')
            conn.commit()
    
    # Whitelist methods
    def is_chat_whitelisted(self, chat_id):
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT 1 FROM whitelisted_chats WHERE chat_id = ?', (chat_id,))
            return cursor.fetchone() is not None
    
    def add_chat_to_whitelist(self, chat_id):
        if not self.is_chat_whitelisted(chat_id):
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('INSERT INTO whitelisted_chats (chat_id) VALUES (?)', (chat_id,))
                conn.commit()
                return True
        return False
    
    def remove_chat_from_whitelist(self, chat_id):
        if self.is_chat_whitelisted(chat_id):
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('DELETE FROM whitelisted_chats WHERE chat_id = ?', (chat_id,))
                conn.commit()
                return True
        return False
    
    # Message storage methods
    def store_message(self, chat_id: int, message_id: int, author: str, 
                     date: datetime.datetime, content: str, tags: str, 
                     importance: MessageImportance = MessageImportance.DEFAULT):
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT INTO messages (chat_id, message_id, author, date, content, tags, important)
                VALUES (?, ?, ?, ?, ?, ?, ?)
                """,
                (chat_id, message_id, author, date.isoformat(), content, tags, importance.value)
            )
            conn.commit()
    
    def get_last_messages(self, chat_id: int, limit: int = 120) -> List[Tuple]:
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Get all important messages
            cursor.execute(
                """
                SELECT message_id, author, date, content, tags, important
                FROM messages
                WHERE chat_id=? AND important='Important'
                ORDER BY id DESC
                """,
                (chat_id,)
            )
            important_messages = cursor.fetchall()
            
            # Get most recent normal messages
            cursor.execute(
                """
                SELECT message_id, author, date, content, tags, important
                FROM messages
                WHERE chat_id=? AND important IN ('None', 'Gemini')
                ORDER BY id DESC
                LIMIT ?
                """,
                (chat_id, limit)
            )
            normal_messages = cursor.fetchall()
            
            # Combine important and normal messages
            return normal_messages + important_messages
```

/docker-compose.yml
```

services:
  bot:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - .:/app
      - data:/app/data
    env_file:
      - .env
    restart: unless-stopped

  bot_2:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - .:/app
      - korbot:/app/data
    env_file:
      - .env.bot2
    restart: unless-stopped
    profiles:
      - bot2 #docker compose up --profile bot2

volumes:
  data:
  korbot:

```

/Dockerfile
```
FROM python:3.13-slim

WORKDIR /app

# Install poetry
RUN pip install poetry

# Copy poetry configuration files
COPY pyproject.toml poetry.lock ./

# Configure poetry to not create a virtual environment
RUN poetry config virtualenvs.create false

# Install dependencies
RUN poetry install --no-interaction --no-ansi

# Copy the application
COPY . .

# Run the application
CMD ["python", "main.py"]
```

/main.py
```
import logging
from bot import app

if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(name)s - %(funcName)s - %(message)s'
    )
    logging.info("Starting Business Bot...")
    app.run()
```

/pyproject.toml
```
[project]
name = "buisbot"
version = "0.1.0"
description = ""
authors = [{ name = "Kotaz", email = "semechkagent@gmail.com" }]
requires-python = ">=3.13,<4.0"
readme = "README.md"
dependencies = [
    "pyrogram (>=2.0.106,<3.0.0)",
    "python-dotenv (>=1.0.0,<2.0.0)",
    "google-genai (>=1.11.0,<2.0.0)",
    "tgcrypto-pyrofork (>=1.2.7,<2.0.0)",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.uv]
package = false
```

/README.md
```
# Business Bot (BuisBot)

–≠—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –±–æ—Ç Telegram (userbot), —Å–æ–∑–¥–∞–Ω–Ω—ã–π –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤, –∞–Ω–∞–ª–∏–∑–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –∏ –º–µ–¥–∏–∞—Ñ–∞–π–ª–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Google Gemini AI. –ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ–¥ –≤–∞—à–∏–º –∞–∫–∫–∞—É–Ω—Ç–æ–º Telegram.

## –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª

* **–•—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π:** –ë–æ—Ç —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤—Å–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –ø–æ–¥–ø–∏—Å–∏ –∫ –º–µ–¥–∏–∞—Ñ–∞–π–ª–∞–º –≤ –ª–æ–∫–∞–ª—å–Ω—É—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö SQLite (`bot_database.db` –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é).
* **–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å Gemini AI:**
  * –ü—Ä–∏ —É–ø–æ–º–∏–Ω–∞–Ω–∏–∏ "–ì–µ–º–∏–Ω–∏," –≤ –Ω–∞—á–∞–ª–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –±–æ—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∏—Å—Ç–æ—Ä–∏—é —á–∞—Ç–∞ –∏ –≤–∞—à –∑–∞–ø—Ä–æ—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞ —Å –ø–æ–º–æ—â—å—é Gemini Flash.
  * –ö–æ–º–∞–Ω–¥–∞ `!–¥—É–º–∞–π` –≤ –∑–∞–ø—Ä–æ—Å–µ –∫ Gemini –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç –±–æ–ª–µ–µ "–≤–¥—É–º—á–∏–≤—É—é" –º–æ–¥–µ–ª—å (`gemini-2.0-flash-thinking-exp-01-21`).
* **–ê–Ω–∞–ª–∏–∑ –º–µ–¥–∏–∞—Ñ–∞–π–ª–æ–≤:** –ö–æ–º–∞–Ω–¥–∞ `!media <–ø—Ä–æ–º–ø—Ç>` (–≤ –æ—Ç–≤–µ—Ç –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –º–µ–¥–∏–∞) –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ç–æ, –≤–∏–¥–µ–æ, –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, GIF –∏–ª–∏ –≤–∏–¥–µ–æ-–∫—Ä—É–∂–æ–∫ —Å –ø–æ–º–æ—â—å—é Gemini.
* **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–∞—Ç–∞–º–∏:**
  * `!enable`: –î–æ–±–∞–≤–ª—è–µ—Ç —Ç–µ–∫—É—â–∏–π —á–∞—Ç –≤ –±–µ–ª—ã–π —Å–ø–∏—Å–æ–∫ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –±–æ—Ç–æ–º.
  * `!disable`: –£–¥–∞–ª—è–µ—Ç —Ç–µ–∫—É—â–∏–π —á–∞—Ç –∏–∑ –±–µ–ª–æ–≥–æ —Å–ø–∏—Å–∫–∞.
* **–û—Ç–º–µ—Ç–∫–∞ –≤–∞–∂–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π:** –ö–æ–º–∞–Ω–¥–∞ `!–ì–µ–º–∏–Ω–∏ <—Å–æ–æ–±—â–µ–Ω–∏–µ>` –ø–æ–º–µ—á–∞–µ—Ç –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–∞–∫ –≤–∞–∂–Ω–æ–µ (–¥–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª—å—Ü—É –±–æ—Ç–∞). –í–∞–∂–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤—Å–µ–≥–¥–∞ –≤–∫–ª—é—á–∞—é—Ç—Å—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è Gemini.
* **–û—Ç–ª–∞–¥–∫–∞:** –ö–æ–º–∞–Ω–¥–∞ `!debug` –≤—ã–≤–æ–¥–∏—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–º –¥–ª—è Gemini.
* **–¢–µ—Å—Ç:** –ö–æ–º–∞–Ω–¥–∞ `!test` –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –±–æ—Ç –∞–∫—Ç–∏–≤–µ–Ω –∏ –æ—Ç–≤–µ—á–∞–µ—Ç.

## –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ –∑–∞–ø—É—Å–∫

–ü—Ä–æ–µ–∫—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Docker –∏ Docker Compose –¥–ª—è –ª–µ–≥–∫–æ–≥–æ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è.

1. **–ö–ª–æ–Ω–∏—Ä—É–π—Ç–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π:**

    ```bash
    git clone <URL —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è>
    cd buisbot
    ```

2. **–°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª `.env`:**
    –°–∫–æ–ø–∏—Ä—É–π—Ç–µ `.env.example` (–µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å) –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª `.env` –≤—Ä—É—á–Ω—É—é —Å–æ —Å–ª–µ–¥—É—é—â–∏–º —Å–æ–¥–µ—Ä–∂–∏–º—ã–º:

    ```dotenv
    API_ID=<–í–∞—à Telegram API ID>
    API_HASH=<–í–∞—à Telegram API HASH>
    SESSION_NAME=business_bot # –ò–º—è —Ñ–∞–π–ª–∞ —Å–µ—Å—Å–∏–∏
    DATABASE_PATH=bot_database.db # –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    GEMINI_API_KEY=<–í–∞—à Google Gemini API Key>
    ```

    * –ü–æ–ª—É—á–∏—Ç—å `API_ID` –∏ `API_HASH` –º–æ–∂–Ω–æ –Ω–∞ [my.telegram.org](https://my.telegram.org/).
    * –ü–æ–ª—É—á–∏—Ç—å `GEMINI_API_KEY` –º–æ–∂–Ω–æ –≤ [Google AI Studio](https://aistudio.google.com/app/apikey).
3. **–ó–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞:**

    ```bash
    docker compose up -d --build
    ```

    –ü—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ –≤–∞–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –≤ Telegram, –≤–≤–µ–¥—è –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏ –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤ –∫–æ–Ω—Å–æ–ª–∏ Docker (`docker logs -f <–∏–º—è_–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞>`). –°–µ—Å—Å–∏—è —Å–æ—Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ —Ñ–∞–π–ª–µ `business_bot.session` (–∏–ª–∏ —Å –∏–º–µ–Ω–µ–º, —É–∫–∞–∑–∞–Ω–Ω—ã–º –≤ `SESSION_NAME`).

## –ó–∞–ø—É—Å–∫ –≤—Ç–æ—Ä–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –±–æ—Ç–∞

–í `docker-compose.yml` –Ω–∞—Å—Ç—Ä–æ–µ–Ω –≤—Ç–æ—Ä–æ–π —Å–µ—Ä–≤–∏—Å `bot_2`, –∫–æ—Ç–æ—Ä—ã–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å `bot2`, –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ñ–∞–π–ª –æ–∫—Ä—É–∂–µ–Ω–∏—è `.env.bot2` –∏ –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ç–æ–º `korbot` –¥–ª—è –¥–∞–Ω–Ω—ã—Ö (–≤–∫–ª—é—á–∞—è —Ñ–∞–π–ª —Å–µ—Å—Å–∏–∏).

1. **–°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª `.env.bot2`:** –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ `.env`, –Ω–æ —Å –¥–∞–Ω–Ω—ã–º–∏ –¥–ª—è –≤—Ç–æ—Ä–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ Telegram –∏, –≤–æ–∑–º–æ–∂–Ω–æ, –¥—Ä—É–≥–∏–º `SESSION_NAME` –∏ `DATABASE_PATH`, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ —Ä–∞–∑–¥–µ–ª–∏—Ç—å –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.

    ```dotenv
    # .env.bot2
    API_ID=<API ID –≤—Ç–æ—Ä–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞>
    API_HASH=<API HASH –≤—Ç–æ—Ä–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞>
    SESSION_NAME=korbot_session # –ù–∞–ø—Ä–∏–º–µ—Ä
    DATABASE_PATH=korbot_database.db # –ù–∞–ø—Ä–∏–º–µ—Ä
    GEMINI_API_KEY=<–í–∞—à Google Gemini API Key>
    ```

2. **–ó–∞–ø—É—Å—Ç–∏—Ç–µ –≤—Ç–æ—Ä–æ–≥–æ –±–æ—Ç–∞:**

    ```bash
    docker compose up --profile bot2 -d --build
    ```

    –¢–∞–∫–∂–µ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ –¥–ª—è —ç—Ç–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞.

## –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–æ–º

* **–í–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ —á–∞—Ç–æ–≤:** –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã `!enable` –∏ `!disable` –≤ –Ω—É–∂–Ω—ã—Ö —á–∞—Ç–∞—Ö. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –±–æ—Ç –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –≤—Å–µ —á–∞—Ç—ã, –∫—Ä–æ–º–µ –õ–° —Å —Å–∞–º–∏–º —Å–æ–±–æ–π.
* **–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å Gemini:** –ü–∏—à–∏—Ç–µ "–ì–µ–º–∏–Ω–∏, <–≤–∞—à –∑–∞–ø—Ä–æ—Å>" –∏–ª–∏ –æ—Ç–≤–µ—á–∞–π—Ç–µ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –º–µ–¥–∏–∞ –∫–æ–º–∞–Ω–¥–æ–π `!media <–≤–∞—à –ø—Ä–æ–º–ø—Ç>`.
* **–í–ª–∞–¥–µ–ª–µ—Ü –±–æ—Ç–∞:** –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID `782491733` (–∑–∞–¥–∞–Ω –≤ `config.py`) –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø –∫ –∫–æ–º–∞–Ω–¥–∞–º `!–ì–µ–º–∏–Ω–∏` –∏ `!debug`.

## –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

–û—Å–Ω–æ–≤–Ω—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —É–∫–∞–∑–∞–Ω—ã –≤ `pyproject.toml`:

* `pyrogram`: –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Telegram API.
* `python-dotenv`: –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ `.env` —Ñ–∞–π–ª–∞.
* `google-genai`: –ö–ª–∏–µ–Ω—Ç –¥–ª—è Google Gemini API.
* `tgcrypto-pyrofork`: –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è Pyrogram.
```

/utils.py
```
import datetime
from typing import List, Tuple
from pyrogram.types import Message

def format_duration(seconds: int) -> str:
    """Format duration in seconds to 'minutes:seconds' format"""
    minutes = seconds // 60
    sec = seconds % 60
    return f"{minutes}:{sec:02d}"

def generate_tags(msg: Message) -> str:
    """Generate descriptive tags for a message based on its content"""
    tags = []

    if msg.photo:
        tags.append("—Å–æ–¥–µ—Ä–∂–∏—Ç —Ñ–æ—Ç–æ")
    if msg.voice:
        duration = msg.voice.duration
        tags.append(f"—Å–æ–¥–µ—Ä–∂–∏—Ç –≥–æ–ª–æ—Å–æ–≤–æ–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é {format_duration(duration)}")
    if msg.document:
        doc = msg.document
        tags.append(f'—Å–æ–¥–µ—Ä–∂–∏—Ç —Ñ–∞–π–ª "{doc.file_name}" ({doc.file_size} –±–∞–π—Ç)')
    if msg.audio:
        audio = msg.audio
        title = audio.title if audio.title else "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        performer = audio.performer if audio.performer else "–Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω"
        tags.append(
            f'—Å–æ–¥–µ—Ä–∂–∏—Ç –º—É–∑—ã–∫—É "{title}" {performer} –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é {format_duration(audio.duration)}'
        )
    if msg.video:
        video = msg.video
        tags.append(f"—Å–æ–¥–µ—Ä–∂–∏—Ç –≤–∏–¥–µ–æ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é {format_duration(video.duration)}")
    if msg.video_note:
        tags.append("—Å–æ–¥–µ—Ä–∂–∏—Ç –≤–∏–¥–µ–æ-—Å–æ–æ–±—â–µ–Ω–∏–µ")
    if msg.contact:
        contact = msg.contact
        tags.append(f'—Å–æ–¥–µ—Ä–∂–∏—Ç –∫–æ–Ω—Ç–∞–∫—Ç "{contact.first_name}"')
    if msg.location:
        tags.append("—Å–æ–¥–µ—Ä–∂–∏—Ç –ª–æ–∫–∞—Ü–∏—é")
    if msg.venue:
        tags.append("—Å–æ–¥–µ—Ä–∂–∏—Ç –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ")
    if msg.sticker:
        tags.append("—Å–æ–¥–µ—Ä–∂–∏—Ç —Å—Ç–∏–∫–µ—Ä")
    if msg.animation:
        tags.append("—Å–æ–¥–µ—Ä–∂–∏—Ç –∞–Ω–∏–º–∞—Ü–∏—é")
    if msg.forward_from:
        tags.append(f'–ø–µ—Ä–µ—Å–ª–∞–Ω–æ –∏–∑ "{msg.forward_from.full_name}"')
    elif msg.forward_from_chat:
        title = msg.forward_from_chat.title if msg.forward_from_chat.title else "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        tags.append(f'–ø–µ—Ä–µ—Å–ª–∞–Ω–æ –∏–∑ "{title}"')
    if msg.reply_to_message:
        tags.append(f"–≤ –æ—Ç–≤–µ—Ç –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ {msg.reply_to_message.id}")
    if msg.sender_chat:
        tags.append(f'–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –æ—Ç –∏–º–µ–Ω–∏ –∫–∞–Ω–∞–ª–∞ "{msg.sender_chat.title}"')
    if msg.via_bot:
        tags.append(f'via bot "{msg.via_bot.first_name}"')

    return ", ".join(tags)

def format_chat_history(messages: List[Tuple]) -> str:
    """Format chat history for display and AI processing"""
    
    lines = []
    # Reverse to show messages from oldest to newest
    for m in reversed(messages):
        msg_id, author, date_str, content, tags, important = m
        i = "[–°–û–û–ë–©–ï–ù–ò–ï –û–¢–ú–ï–ß–ï–ù–û –í–ê–ñ–ù–´–ú] " if important == "Important" else ""
        
        if important == "Gemini":
            author = "Gemini"
            
        date_obj = datetime.datetime.fromisoformat(date_str)
        date_formatted = date_obj.strftime('%Y-%m-%d %H:%M:%S')
        
        if tags:
            line = f"{i}{msg_id} {date_formatted} {author} ({tags}): {content}"
        else:
            line = f"{i}{msg_id} {date_formatted} {author}: {content}"
            
        lines.append(line)
        
    return "\n".join(lines)

def prevent_injection(text: str) -> str:
    """Prevent userbot injection by replacing special characters"""
    text = text.replace(".e", ",e")
    return text```

